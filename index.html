<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script>
      // Constants you can change:
      let hz = 18000;
      let numStd = 4;
      let ticksRequiredForDetection = 25;
      let regularPeriod = 4200;

      // Other state
      let t0 = -1;
      let bucket = -1;
      let audioCtx = null;
      let analyser = null;
      let source = null;
      let state = null;
      let threshold = 256 * 0.6;
      let currentAdjustedPeriod = Math.random() * regularPeriod;

      function getTimeFlown() {
	return performance.now() - t0
      }

      function frequencySliderChanged () {
	let slider = document.getElementById("frequencySlider");
	hz = slider.value;
      }

      function setState(newState) {
        state = newState;
        if (state === "Flashing") {
          document.getElementById("body").setAttribute("style", "background-color: #fff");
        } else {
          document.getElementById("body").setAttribute("style", "background-color: #333");
        }
        document.getElementById("state").innerText = state;
      }

      function go() {
        setState("Listening");
	let t0 = performance.now()
	document.getElementById("freeze").removeAttribute('disabled');
	listen();
      }

      function freeze() {
	  setState("Frozen");
	  document.getElementById("freeze").disabled = true;
      }

      function getAvg(arr) {
	  let sum = 0;
	  for (let i = 0; i < arr.length; i++) {
	      sum += arr[i];
	  }
	  return sum / arr.length;
      }

      function getSumSqDiffAvg(arr) {
	  let avg = getAvg(arr);
	  let sumSqDiffAvg = 0;
	  for (let i = 0; i < arr.length; i++) {
	      sumSqDiffAvg += (arr[i] - avg) * (arr[i] - avg)
	  }
	  return sumSqDiffAvg;
      }

      function getStd(arr) {
	  let sumSqDiffAvg = getSumSqDiffAvg(arr);
	  let std = Math.sqrt(sumSqDiffAvg) / arr.length
	  return std
      }

      function getLocalStd(arr, minFrac, maxFrac) {
	  minBucket = Math.floor(arr.length * minFrac)
	  maxBucket = Math.floor(arr.length * maxFrac)
	  return getStd(arr.slice(minBucket, maxBucket))
      }

      function isPointy(dataArray, idx, w, threshold) {
	  if (dataArray[idx] < threshold) {
	      return false;
	  }
	  if (idx > dataArray.length - w) {
	      return false;
	  }
	  for (let j = -Math.floor(w/2); j < Math.floor(w/2); j++) {
	      if (Math.abs(j) < 2) {
		  continue;
	      }
	      if (dataArray[idx] / dataArray[idx + j] < 2 &&
		  dataArray[idx] / dataArray[idx + j] < 2) {
		  return false;
	      }
	  }
	  return true;
      }

      function setup() {
        let slider = document.getElementById("frequencySlider");
        slider.value = hz;
        // create web audio api context
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 2048;

        if (navigator.mediaDevices.getUserMedia) {
          navigator.mediaDevices.getUserMedia({audio: true})
            .then(function(stream) {
              source = audioCtx.createMediaStreamSource(stream);
              source.connect(analyser);

              document.getElementById("setup").setAttribute('disabled', 'disabled');
              document.getElementById("go").removeAttribute('disabled');

              setState("Talking to myself");
              listen();
              emit(function() {
                setState("Calculating threshold");
              });
            }).catch(function(err) {
              console.log('The following error occurred: ' + err);
            })
        } else {
          console.log('getUserMedia not supported on your browser!');
        }
      }

      function emit(callback) {
        const oscillator = audioCtx.createOscillator();
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(hz, audioCtx.currentTime); // value in hertz
        oscillator.connect(audioCtx.destination);
        oscillator.start();
        setTimeout(function() {
          oscillator.stop();
          if (callback) callback();
        }, 1000);
      }

      function listen() {
        let bufferLength = analyser.frequencyBinCount;
        let dataArray = new Uint8Array(bufferLength);
        // analyser.getByteFrequencyData(dataArray);

        // Get a canvas defined with ID "oscilloscope"
        let canvas = document.getElementById("oscilloscope");
        let canvasCtx = canvas.getContext("2d");

        let count = 0;
        let sum = 0;
        let varSum = 0;
        let ticksAboveThreshold = 0;
        let argmaxes = {};

        function draw() {
	  if (state === "Frozen") {
	      return;
	  }

	  requestAnimationFrame(draw);
	  analyser.getByteFrequencyData(dataArray);

          canvasCtx.fillStyle = "rgb(200, 200, 200)";
          canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

          canvasCtx.lineWidth = 2;
          canvasCtx.strokeStyle = "rgb(0, 0, 0)";

          canvasCtx.beginPath();

          let sliceWidth = canvas.width * 1.0 / bufferLength;
          let x = 0;
	  let xPrev = 0;
	  let yPrev = 0;

          let lastSegmentWasPointy = false;
	  let finishPeak = false;
	  // Only set if you promise never to use a lower frequency signal
	  // This value is the fraction of the frequency range you'll
	  // never try
	  let rangeMin = 0.1;
          let globalAvg = getAvg(dataArray);
	  let rangedStd = getLocalStd(dataArray, rangeMin, 1);
          for (let i = 0; i < bufferLength; i++) {
            let v = dataArray[i] / 128.0;

            let y = canvas.height - v * canvas.height / 2;

            if (i === 0) {
              canvasCtx.moveTo(x, y);
            } else {
		if (i < Math.floor(dataArray.length * rangeMin)) {
		  canvasCtx.lineTo(x, y);
		} else if (lastSegmentWasPointy) {
		    // If still part of peak
		    if (y > yPrev * 0.9) {
			canvasCtx.lineTo(x, y);
		    } else {
			canvasCtx.lineTo(x, y);
			finishPeak = true;
			lastSegmentWasPointy = false;
		    }
		} else if (finishPeak) {
		    finishPeak = false;
		    // Draw the descending half of the peak
		    canvasCtx.lineTo(x, y);
		    canvasCtx.strokeStyle = 'green';
		    canvasCtx.stroke()

		    canvasCtx.beginPath();
		    canvasCtx.moveTo(xPrev, yPrev);
		    canvasCtx.strokeStyle = 'black';
		} else if (isPointy(dataArray, i, 5, globalAvg + 5*rangedStd)) {
		    // Draw last segment as black
		    canvasCtx.stroke();

		    canvasCtx.beginPath();
		    canvasCtx.moveTo(xPrev, yPrev);
		    canvasCtx.lineTo(x, y);
		    lastSegmentWasPointy = true;
		    noLongerPointy = false;
		} else {
		  canvasCtx.lineTo(x, y);
		}
            }
            xPrev = x
            yPrev = y
            x += sliceWidth;
          }

          canvasCtx.lineTo(canvas.width, canvas.height / 2);
          canvasCtx.stroke();

          if (state === "Talking to myself") {
            let max = 0;
            let argmax = -1;
            for (let i = Math.floor(bufferLength / 4); i < bufferLength; i++) {
              if (dataArray[i] > max) {
                max = dataArray[i];
                argmax = i;
              }
            }
            argmaxes[argmax] = argmaxes[argmax] || 0;
            argmaxes[argmax]++;
          } else if (state === "Calculating threshold") {
            console.log("Popular buckets: ", argmaxes);
            let max = -1;
            Object.keys(argmaxes).forEach(function (argmax) {
              if (argmaxes[argmax] > max) {
                max = argmaxes[argmax];
                bucket = argmax;
              }
            });
            console.log("Detected bucket: ", bucket);
            setState("Ready");
            //
            // count++;
            // buckets.forEach((bucket) => {
            //   sum = sum + dataArray[bucket];
            // });
            // buckets.forEach((bucket) => {
            //   varSum = varSum + Math.pow(dataArray[bucket] - (sum / count), 2);
            // });
            // // threshold = (sum / count) + numStd * Math.sqrt(varSum / count);
            // threshold = buckets.length * 256 * 0.6;
            // console.log("Threshold: ", threshold);
            //
            //
          } else {
            if (state === "Listening" || state === "Heard a tone") {
              // Check for tones
              if (dataArray[bucket] > threshold) {
                ticksAboveThreshold++;
                if (state !== "Heard a tone" && ticksAboveThreshold > ticksRequiredForDetection) {
                    setState("Heard a tone");
		  // weird convergence
                  // fireflyTime = (fireflyPeriod - fireflyTime) / 2.0;
                    currentAdjustedPeriod = (regularPeriod - getTimeFlown()) / 2.0;
		  console.log("Tone!");
                }
              } else {
                setState("Listening");
                ticksAboveThreshold = 0;
              }
            }
            // Possibly flash
            if (getTimeFlown() > currentAdjustedPeriod) {
	      t0 = performance.now();
              currentAdjustedPeriod = regularPeriod;
              if (state === "Listening" || state === "Heard a tone") {
                setState("Flashing");
                emit(function () {
                  setTimeout(function () {
                    setState("Listening")
                  }, 250);
                });
              }
            }
          }
        }

        draw();
      }
    </script>
  </head>
  <body id="body">
    <div><button id="setup" onclick="setup()">setup!</button></div>
    <div><button id="go" disabled="disabled" onclick="go()">go!</button></div>
    <div><button id="freeze" disabled="disabled" onclick="freeze()">freeze!</button></div>
    <h2 id="state" style="color: #888"></h2>
    <div><input id="frequencySlider" type="range" min="20" max="20000" value="" style="width: 80%" oninput="frequencySliderChanged()" onchange="frequencySliderChanged()"></div>
    <canvas id="oscilloscope"></canvas>
  </body>
</html>
